# QRyptEye - Air-Gapped Secure Messaging

End-to-end encryption built into secure messaging apps is great. But what if your endpoint is compromised, ala Pegasus? QRyptEye is an Android application designed for secure, air-gapped messaging using QR codes. The app is intended for installation and use on a secondary, offline-only device. It ensures that plain text messages never touch an exposed device, providing an additional layer security for sensitive communications. 

## üõ°Ô∏è Security Model

### Air-Gapped Communication
- **Offline Device**: QRyptEye runs on a device that is never connected to the internet
- **QR Code Transfer**: Encrypted messages are transferred to an online device by taking a photo of the QR code generated by QRypteye
- **No Plain Text Exposure**: Plain text messages are never exposed to the primary device that touches the internet

### Cryptographic Implementation
- **Hybrid Encryption**: Uses RSA-2048 for key exchange and AES-256 for message encryption
- **Key Management**: Secure generation and storage of cryptographic key pairs
- **BouncyCastle**: Industry-standard cryptographic library for robust security

### Digital Signatures and Authentication
- **Message Signing**: All encrypted messages are digitally signed using RSA-2048 with SHA-256
- **Authenticity Verification**: Recipients can verify that messages came from the claimed sender
- **Tamper Detection**: Any modification to the encrypted message will cause signature verification to fail
- **Non-Repudiation**: Senders cannot deny sending messages they have signed
- **Trust-on-First-Use**: Initial key exchange follows a trust-on-first-use model without digital signatures

## üîÑ Workflow

### Adding a Trusted Contact
1. **Generate Keys**: Each user generates RSA key pairs on their offline devices
2. **Share Public Key**: User creates a QR code containing their public key and name
3. **Transfer**: User photographs the QR code with their online device
4. **Send**: QR code image is sent via any chosen method (email, messaging, etc.)
5. **Import**: Recipient scans the QR code on their offline device to add the contact
6. **Secure**: Private keys never leave the offline device

### Sending a Message
1. **Compose**: User writes a plain text message on the offline device
2. **Encrypt**: QRyptEye encrypts the message using the recipient's public key (exchanged when adding a contact)
3. **Generate QR**: App creates a QR code containing the encrypted message
4. **Transfer**: User photographs the QR code with their online device
5. **Send**: QR code image is sent via any chosen method (email, messaging, etc.)

### Receiving a Message
1. **Receive**: User receives the QR code image on their online device
2. **Transfer**: QR code is scanned by the offline device using the camera
3. **Decrypt**: QRyptEye decrypts the message using the user's private key
4. **Read**: Plain text message is displayed on the offline device

## üöÄ Features

### Core Functionality
- **Message Composition**: Write and encrypt messages for specific recipients
- **QR Code Generation**: Create QR codes for encrypted messages and public keys
- **QR Code Scanning**: Scan QR codes to decrypt messages or import public keys
- **Key Management**: Generate, export, and manage cryptographic keys

### User Interface
- **Modern Material Design**: Clean, intuitive interface following Material Design 3
- **Security Warnings**: Clear reminders about offline-only usage
- **Contact Management**: Organize and manage recipient public keys
- **Message History**: View and manage sent/received messages

### Security Features
- **Camera Permissions**: Secure camera access for QR code scanning
- **Storage Permissions**: Controlled access for saving QR codes
- **Backup Exclusion**: Sensitive data excluded from device backups
- **Secure Storage**: Cryptographic keys stored securely

## üì± Technical Requirements

### Android Version
- **Minimum SDK**: API 24 (Android 7.0)
- **Target SDK**: API 34 (Android 14)
- **Compile SDK**: API 34

### Permissions
- **Camera**: Required for QR code scanning
- **Storage**: Optional for saving QR codes locally

### Dependencies
- **CameraX**: Modern camera API for QR code scanning
- **ZXing**: QR code generation and scanning library
- **BouncyCastle**: Cryptographic operations
- **Material Design**: UI components and theming
- **Gson**: JSON serialization for data structures

## üîß Building the Project

### Prerequisites
- Android Studio Arctic Fox or later
- Android SDK API 34
- Gradle 8.0+

### Build Steps
1. Clone the repository
2. Open the project in Android Studio
3. Sync Gradle dependencies
4. Build the project
5. Install on target device

### Build Commands
```bash
# Clean build
./gradlew clean

# Build debug APK
./gradlew assembleDebug

# Build release APK
./gradlew assembleRelease
```

## üõ†Ô∏è Architecture

### Package Structure
```
com.qrypteye.app/
‚îú‚îÄ‚îÄ crypto/          # Cryptographic operations
‚îú‚îÄ‚îÄ data/            # Data models and entities
‚îú‚îÄ‚îÄ qr/              # QR code generation and parsing
‚îú‚îÄ‚îÄ ui/              # User interface activities
‚îî‚îÄ‚îÄ MainActivity.kt  # Main application entry point
```

### Key Components
- **CryptoManager**: Handles encryption, decryption, and key management
- **QRCodeManager**: Manages QR code generation and parsing
- **Data Models**: Contact, Message, and SecureMessage classes
- **UI Activities**: ComposeMessage, ScanQR, and KeyManagement activities

## üîí Security Considerations

### Best Practices
1. **Never connect the offline device to the internet**
2. **Keep private keys secure and never share them**
3. **Verify QR codes visually before scanning**
4. **Use strong, unique passwords for device protection**
5. **Regularly update the app for security patches**

### Cryptographic Security
- **Key Generation**: All cryptographic keys are generated using cryptographically secure random number generators (SecureRandom)
- **Key Derivation**: The app does NOT support password-derived keys. If you ever need to implement password-based key derivation:
  - Use PBKDF2 with at least 100,000 iterations
  - Use scrypt with N=16384, r=8, p=1 minimum
  - Use Argon2 with appropriate parameters
  - Always use a salt of at least 16 bytes
  - Never use weak entropy sources (Math.random(), timestamps, etc.)
- **Algorithm Security**: Uses RSA-2048 with OAEP padding and AES-256-GCM for authenticated encryption
- **Secure Storage**: All sensitive data is stored using EncryptedSharedPreferences:
  - Private keys encrypted with AES-256-GCM
  - All data encrypted with AES-256-GCM
  - Master key protected by Android Keystore
  - No plaintext storage of sensitive information
  - Automatic migration from legacy storage
- **Encryption at Rest**: Field-level encryption for sensitive data:
  - Message content encrypted with AES-256-GCM
  - Contact names encrypted with AES-256-GCM
  - User names encrypted with AES-256-GCM
  - Cryptographic signatures remain unencrypted for verification
  - Public keys remain unencrypted for functionality
  - Protection against file system access attacks
- **Android Keystore Integration**: Private keys are generated and stored within Android Keystore:
  - Private keys never leave the secure hardware environment
  - Hardware-backed security on supported devices
  - No serialization or export of private keys
  - Protection against key extraction attacks
  - Key aliases for secure reference
  - **CRITICAL SECURITY FIX**: Removed KeyPairData class that contained privateKeyString field
  - Private keys are now accessed directly from KeyPair objects without serialization
  - Complete elimination of private key string storage vulnerability
  - **Proper Android Keystore Usage**: Keys generated using KeyPairGenerator.getInstance("RSA", "AndroidKeyStore")
  - **Secure Key Access**: Private keys accessed only by alias via keyStore.getKey(keyAlias, null)
  - **No Key Export**: Private keys never serialized, exported, or converted to strings
  - **Hardware-backed Security**: Leverages device's secure hardware when available
- **Message Integrity and Authenticity**: All messages are cryptographically signed:
  - RSA-2048 signatures with SHA-256 for message authenticity
  - Unique message IDs to prevent replay attacks
  - Timestamp validation for message freshness
  - Sender verification through public key validation
  - Tamper detection through signature verification
  - No reliance on weak heuristics for duplicate detection
  - **Enhanced Signature Format**:
    - Canonical JSON serialization for unambiguous parsing
    - All message fields signed (id, sender, recipient, content, timestamp, direction, read status)
    - Signature context to prevent signature reuse attacks
    - Versioned signature format for future compatibility
    - Protection against field injection and tampering
- **Replay Attack Protection**: Messages and public keys are validated for freshness:
  - Messages older than 24 hours are rejected
  - Messages from the future (beyond 5 minutes clock skew) are rejected
  - Public key QR codes are also validated for freshness
  - Prevents replay attacks where old messages are re-sent
  - **Enhanced Replay Protection System**:
    - Tracks previously seen message IDs to prevent exact duplicates
    - Tracks message content hashes to prevent content-based replays
    - **NEW**: Tracks session nonces to prevent nonce reuse attacks
    - Uses SHA-256 hashing for secure message fingerprinting
    - Thread-safe concurrent access for high-performance protection
    - Automatic cleanup of old entries to prevent memory exhaustion
    - Protection against memory exhaustion attacks (max 10,000 tracked messages)
    - Rejects messages with duplicate IDs, content hashes, or session nonces
    - **Enhanced with Session Nonces**: Each message includes a unique 96-bit session nonce
    - **Multi-layered Protection**: ID-based, content-based, and nonce-based replay detection
  - **Timestamp Regression Protection**:
    - Tracks latest timestamp per sender to prevent regression attacks
    - Rejects messages with timestamps earlier than previously seen from same sender
    - Validates clock drift (2 minutes maximum allowed)
    - Uses sender public key hash for secure identification
    - Automatic cleanup of old sender entries (7 days)
    - Protection against timestamp manipulation and replay attacks

### Security Logging and Auditing
- **Comprehensive Security Logging**: All cryptographic operations are logged for audit purposes:
  - Message verification success/failure events
  - Replay attack detection events
  - Timestamp regression detection events
  - Invalid signature events
  - Key generation and rotation events
  - Encryption and decryption success/failure events
  - Clock drift detection events
- **Secure Logging Practices**:
  - No sensitive data (private keys, message content) logged
  - Uses secure hashing for message and sender identification
  - Categorized event types for easy analysis
  - Thread-safe logging with size limits to prevent exhaustion
  - Automatic cleanup of old log entries
- **User Feedback and Transparency**:
  - Users can see when message verification fails vs silent drops
  - Key rotation and generation events are logged and visible
  - Security statistics available for user awareness
  - Recent security events accessible for debugging
  - Clear distinction between different types of security failures

### Limitations
- **QR Code Size**: Large messages may require multiple QR codes (426 character max per QR code)
- **QR Readability**: Poor camera quality, lighting conditions, or glare may affect QR code scanning
- **Physical Security**: Device must be physically secure
- **Trust-on-First-Use Model**: No authenticity checks occur during initial key exchange. For maximum security, perform initial key exchange in person. 

## üìÑ License

This project is licensed under the MIT License - see the LICENSE file for details.

## ü§ù Contributing

Contributions are welcome! Please ensure that:
1. All cryptographic code follows security best practices
2. UI changes maintain the security-focused design
3. Code is well-documented and tested
4. Security implications are carefully considered

## ‚ö†Ô∏è Disclaimer

This software is provided "as is" without warranty. Users are responsible for:
- Understanding the security model and limitations
- Properly securing their devices and keys
- Verifying the integrity of received messages
- Complying with applicable laws and regulations

## üìû Support

For questions, issues, or security concerns:
- Create an issue on the project repository
- Review the security documentation
- Test thoroughly before using for sensitive communications

---

**Remember**: QRyptEye is designed for air-gapped communication. Never connect the offline device to any network for maximum security. 